<h1 id="readme-for-filter-authors">README for filter authors</h1>
<p>This template makes extensive use of the <a href="https://metacpan.org/pod/Data::Rmap">Data::Rmap module</a> to iterate recursively through the Pandoc document data, so you should read the documentation of that module.</p>
<h2 id="get-filter-options-from-pandoc-metadata">Get filter options from pandoc metadata</h2>
<pre><code>my $opts_href = get_meta_opts( 
    +{ doc =&gt; $doc, opts =&gt; \@opts, default =&gt; \%opts, prefix =&gt; $pfx }
);</code></pre>
<dl>
<dt><code>doc =&gt; $doc</code></dt>
<dd>Data structure representing a Pandoc AST decoded from JSON produced by pandoc. Required.
</dd>
<dt><code>opts =&gt; \@opts</code></dt>
<dd>Arrayref of option names, without prefix. Required.
</dd>
<dt><code>default =&gt; \%opts</code></dt>
<dd>Optional hashref of option defaults, keyed on option names without prefix. If an option is missing from the metadata it will get the corresponding value from this hashref.
</dd>
<dt><code>prefix =&gt; $pfx</code></dt>
<dd>optional string prefixed to option names to get metadata keys if the option name is 'foo' and the prefix is 'filter-name-' then the metadata key for that option is 'filter-name-foo', but the key in the returned <code>$opts_href</code> will be 'foo'. This is so that you can tell which options are for this particular filter, but won't need to type the prefix when accessing elements in the options hashref.
</dd>
</dl>
<p>Returns a hashref with OPTION =&gt; VALUE pairs, without prefix.</p>
<p>Rules for finding an option value:</p>
<ol style="list-style-type: decimal">
<li><p>If the metadata value is not a MetaMap or MetaList:</p>
<p>Returns the value of the first Str, MetaString, Bool, Code or CodeBlock found in the metadata value.</p></li>
<li><p>If the metadata value is a MetaMap:</p>
<p>Returns a hashref where the keys are the keys of the MetaMap and the values are obtained by recursively applying these rules to the corresponding MetaMap value.</p></li>
<li><p>If the metadata value is a MetaList:</p>
<p>Returns a plain arrayref with the values obtained from the MetaList values by recursively applying these rules.</p></li>
</ol>
<p>Bottom line: you get a data structure as similar to your metadata YAML block, with non-list, non-map values truncated as per rule 1. This means you will get strings or JSON::Boolean objects (which stringify as <code>0|1</code>), possibly as values of possibly nested hash or array references.</p>
<h2 id="iterate-over-each-pandoc-text-element-in-the-document">Iterate over each Pandoc text element in the document</h2>
<pre><code>rmap_hash { BLOCK } $doc;</code></pre>
<p>The BLOCK is actually a subroutine closure. It will be called once for each hashref in <code>$doc</code>, with <code>$_</code> aliased to the hashref.</p>
<p>If you want to abort processing of the current element you should <code>return</code> without an argument; this is the equivalent of <code>next</code> in a true loop block.</p>
<p>If you want to replace the current element with another you should assign the new element to <code>$_</code>. The return value from BLOCK isn't very useful in our case, since Data::</p>
<p>Normally you should first check that <code>$_</code></p>
<p>Normally the hashref represents a JSON object which represents an element in the pandoc AST; however this is not always true in the metadata section, so you should at least check that there is a non-false 't' key and a defined 'c' key in the hashref. If someone populates a metadata map with two such keys disaster may ensue, so you might want to warn against that! The return value of the BLOCK is ignored by most filters, but Data::Rmap collects whatever is returned from the BLOCK and returns the collected list from rmap_hash()! Return an empty list/return without arguments to break out of BLOCK. To not visit the contents of the current hashref break out of the BLOCK by calling cut(); To alter or replace the current element alter the contents of <code>$_</code> or assign to <code>$_</code>, Just make sure that <code>$_</code> contains a valid element object hashref!</p>
<p>Make sure to read the documentation for the <a href="https://metacpan.org/pod/Data::Rmap">Data::Rmap module</a>.</p>
<p>rmap_element_lists { BLOCK } $doc;</p>
<p>The BLOCK is actually a subroutine closure. It will be called once for each element in each list in <code>$doc</code> with only hashrefs as values, with <code>$_</code> aliased to the hashref. Normally the hashref represents a JSON object which represents an element in the pandoc AST; however this is not always true in the metadata section, so you should at least check that there is a non-false 't' key and a defined 'c' key in the hashref. If someone populates a metadata map with two such keys disaster may ensue, so you might want to warn against that! Whatever is returned from the BLOCK is pushed onto the replacement list: to keep the original hashref return <code>$_</code> to skip this element return an empty list/return without elements Only ever return an empty list or a (list of) valid element object hash(es)!</p>
